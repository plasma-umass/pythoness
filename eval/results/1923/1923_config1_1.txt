class Solution:
    
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        
        from collections import defaultdict
    
        def rolling_hash(path, length, base, mod):
            curr_hash = 0
            base_powers = [1] * (len(path) + 1)
            for i in range(1, len(base_powers)):
                base_powers[i] = base_powers[i - 1] * base % mod
            for i in range(length):
                curr_hash = (curr_hash * base + path[i]) % mod
            hashes = defaultdict(list)
            hashes[curr_hash].append(0)
            for i in range(length, len(path)):
                curr_hash = (curr_hash * base - path[i - length] * base_powers[length] + path[i]) % mod
                if curr_hash < 0:
                    curr_hash += mod
                hashes[curr_hash].append(i - length + 1)
            return hashes
    
        def valid(length):
            base = 257
            mod1 = 10 ** 9 + 7
            mod2 = 10 ** 9 + 9
            all_plain_hashes1 = rolling_hash(paths[0], length, base, mod1)
            all_plain_hashes2 = rolling_hash(paths[0], length, base, mod2)
            for i in range(1, len(paths)):
                path_hashes1 = rolling_hash(paths[i], length, base, mod1)
                path_hashes2 = rolling_hash(paths[i], length, base, mod2)
                new_all_plain_hashes1 = defaultdict(list)
                new_all_plain_hashes2 = defaultdict(list)
                for h1 in path_hashes1:
                    if h1 in all_plain_hashes1:
                        new_all_plain_hashes1[h1] = min(all_plain_hashes1[h1], path_hashes1[h1])
                all_plain_hashes1 = new_all_plain_hashes1
                for h2 in path_hashes2:
                    if h2 in all_plain_hashes2:
                        new_all_plain_hashes2[h2] = min(all_plain_hashes2[h2], path_hashes2[h2])
                all_plain_hashes2 = new_all_plain_hashes2
                if not all_plain_hashes1 or not all_plain_hashes2:
                    return False
            return True
        (left, right) = (0, min((len(path) for path in paths)))
        answer = 0
        while left <= right:
            mid = (left + right) // 2
            if valid(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        return answer