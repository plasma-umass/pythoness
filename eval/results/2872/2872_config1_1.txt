class Solution:
    
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        
        from collections import defaultdict
    
        def dfs(node, parent):
            subtree_sum = values[node]
            for neighbor in tree[node]:
                if neighbor != parent:
                    subtree_sum += dfs(neighbor, node)
            # If the subtree sum including this node is divisible by k, we can consider it as a component and exclude the edge from parent.
            if subtree_sum % k == 0:
                nonlocal max_components
                max_components += 1
                return 0  # If the component is valid, return 0 since we don't carry over any value upwards.
            return subtree_sum  # If not valid, return the subtree_sum to parent.
        # Create adjacency list for the undirected tree.
        tree = defaultdict(list)
        for (a, b) in edges:
            tree[a].append(b)
            tree[b].append(a)
        # We start with 0 components because we need at least one whole tree component to start with.
        max_components = 0
        root_to_all_sum = dfs(0, -1)  # Start dfs from any node, here node 0
        return max_components